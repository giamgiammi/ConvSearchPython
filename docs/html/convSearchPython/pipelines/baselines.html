<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>convSearchPython.pipelines.baselines API documentation</title>
<meta name="description" content="Collection of baselines runs" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>convSearchPython.pipelines.baselines</code></h1>
</header>
<section id="section-intro">
<p>Collection of baselines runs</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Collection of baselines runs&#34;&#34;&#34;
from abc import ABC
from multiprocessing.pool import Pool
from pathlib import Path
from typing import Optional, Union

import pandas as pd

from convSearchPython.dataset import Conversations
from convSearchPython.pipelines import AbstractParallelPipeline, Model, RM3
from convSearchPython.searching.rewriter.concat_query import ConcatQueryRewriter
from convSearchPython.searching.rewriter.context_query import ContextQueryRewriter
from convSearchPython.searching.rewriter.coref_query import AllennlpCoreferenceQueryRewriter
from convSearchPython.searching.rewriter.first_query import FirstQueryRewriter
from convSearchPython.searching.rewriter.neuralcoref_coref_query import NeuralCorefRewriter


class PlainPipeline(AbstractParallelPipeline):
    &#34;&#34;&#34;
    DirichletLM pipeline with no query rewriting and optional RM3

    Configure with:

    ```
    plain = convSearchPython.pipelines.baselines.PlainPipeline
    plain.mu = 2500
    plain.rm3 = false
    plain.fb_terms = 20
    plain.fb_docs = 20
    plain.fb_lambda = 0.5
    ```
    &#34;&#34;&#34;
    def __init__(self, index: str, metadata: list, rm3=False, mu=2500, fb_terms=20, fb_docs=20,
                 fb_lambda=0.5, **kwargs):
        &#34;&#34;&#34;
        Args:
            index: index to use (as RetrieveMetadata enum)
            metadata: metadata to retrieve
            rm3: if to apply RM3
            mu: mu parameter of dirichlet language model
            fb_terms: RM3 term number
            fb_docs: RM3 number of docs
            fb_lambda: RM3 lambda
            **kwargs: extra unused arguments
        &#34;&#34;&#34;
        super().__init__(**kwargs)
        self._index = index
        self._metadata = metadata
        self._fb_terms = fb_terms
        self._fb_docs = fb_docs
        self._fb_lambda = fb_lambda
        self._apply_rm3 = rm3
        self._mu = mu

        steps = [Model(&#39;DirichletLM&#39;, {&#39;c&#39;: self._mu}, self._index, self._metadata)]
        if self._apply_rm3:
            steps.append(RM3(self._index, self._fb_terms, self._fb_docs, self._fb_lambda))
            steps.append(steps[0])
        self._steps = steps

    def run_on(self, queries: pd.DataFrame, parallel_pool: Optional[Pool] = None) -&gt; pd.DataFrame:
        results = queries

        if parallel_pool is None:
            for step in self._steps:
                results = step(results)
            return results

        for step in self._steps:
            results = self._parallel_run(step, parallel_pool, queries)
        return results

    @property
    def name(self):
        &#34;&#34;&#34;DLM_none_[rm3]&#34;&#34;&#34;
        if self._apply_rm3:
            return f&#39;{self._steps[0].name}_none_{self._steps[1].name}&#39;
        return f&#39;{self._steps[0].name}_none_none&#39;


class AbstractDLMConversationalPipeline(PlainPipeline, ABC):
    &#34;&#34;&#34;
    Abstract class for conversational pipeline with DLM and optional RM3
    &#34;&#34;&#34;
    def __init__(self, conversations: Conversations, **kwargs):
        &#34;&#34;&#34;
        Args:
            conversations: conversations structure
            **kwargs: same arguments of `PlainPipeline`
        &#34;&#34;&#34;
        super().__init__(**kwargs)
        self._conversations = conversations

    def run_on(self, queries: pd.DataFrame, parallel_pool: Optional[Pool] = None) -&gt; pd.DataFrame:
        results = queries

        if parallel_pool is None:
            for step in self._steps:
                results = step(results)
            return results

        for step in self._steps:
            results = self._conv_parallel_run(step, parallel_pool, results, self._conversations)

        return results


class FirstQueryPipeline(AbstractDLMConversationalPipeline):
    &#34;&#34;&#34;
    DirichletLM pipeline with first query rewriting and optional RM3

    Configure with:

    ```
    first = convSearchPython.pipelines.baselines.FirstQueryPipeline
    first.mu = 2500
    first.rm3 = false
    first.fb_terms = 20
    first.fb_docs = 20
    first.fb_lambda = 0.5
    ```
    &#34;&#34;&#34;

    def __init__(self, variant=&#39;no-repeat&#39;, **kwargs):
        &#34;&#34;&#34;
        Args:
            variant: rewriter variant. Check `convSearchPython.searching.rewriter.first_query.FirstQueryRewriter`
            for more information.
            conversations: conversations structure
            index: index to use (as RetrieveMetadata enum)
            metadata: metadata to retrieve
            rm3: if to apply RM3
            mu: mu parameter of dirichlet language model
            fb_terms: RM3 term number
            fb_docs: RM3 number of docs
            fb_lambda: RM3 lambda
            **kwargs: same arguments of `PlainPipeline`
        &#34;&#34;&#34;
        super().__init__(**kwargs)
        self._steps = [FirstQueryRewriter(variant=variant, **kwargs)] + self._steps

    def run_on(self, queries: pd.DataFrame, parallel_pool: Optional[Pool] = None) -&gt; pd.DataFrame:
        results = queries

        if parallel_pool is None:
            for step in self._steps:
                results = step(results)
            return results

        for step in self._steps:
            results = self._conv_parallel_run(step, parallel_pool, results, self._conversations)

    @property
    def name(self):
        &#34;&#34;&#34;DLM_FirstQ_[rm3]&#34;&#34;&#34;
        if self._apply_rm3:
            return f&#39;{self._steps[1].name}_{self._steps[0].name}_{self._steps[2].name}&#39;
        return f&#39;{self._steps[1].name}_{self._steps[0].name}_none&#39;


class ContextQueryPipeline(AbstractDLMConversationalPipeline):
    &#34;&#34;&#34;
    DirichletLM pipeline with context query rewriting and optional RM3
    &#34;&#34;&#34;
    def __init__(self, variant=&#39;no-repeat&#39;, **kwargs):
        &#34;&#34;&#34;
        Args:
            variant: rewriter variant. Check `convSearchPython.searching.rewriter.context_query.ContextQueryRewriter`
            for more information.
            conversations: conversations structure
            index: index to use (as RetrieveMetadata enum)
            metadata: metadata to retrieve
            rm3: if to apply RM3
            mu: mu parameter of dirichlet language model
            fb_terms: RM3 term number
            fb_docs: RM3 number of docs
            fb_lambda: RM3 lambda
            **kwargs: same arguments of `PlainPipeline`
        &#34;&#34;&#34;
        super().__init__(**kwargs)
        self._steps = [ContextQueryRewriter(variant=variant, **kwargs)] + self._steps

    @property
    def name(self):
        &#34;&#34;&#34;DLM_ContextQ_[rm3]&#34;&#34;&#34;
        if self._apply_rm3:
            return f&#39;{self._steps[1].name}_{self._steps[0].name}_{self._steps[2].name}&#39;
        return f&#39;{self._steps[1].name}_{self._steps[0].name}_none&#39;


class Coreference1Pipeline(AbstractDLMConversationalPipeline):
    &#34;&#34;&#34;
    DirichletLM pipeline with Coref1 (alennlp) query rewriting and optional RM3
    &#34;&#34;&#34;
    def __init__(self, cache_dir: Union[str, Path], allow_cuda=True, autosave=True, **kwargs):
        &#34;&#34;&#34;
        Args:
            cache_dir: the cache dir path (None disable cache)
            allow_cuda: if True cuda is used if available
            autosave: if True the cache is automatically saved
            conversations: conversations structure
            index: index to use (as RetrieveMetadata enum)
            metadata: metadata to retrieve
            rm3: if to apply RM3
            mu: mu parameter of dirichlet language model
            fb_terms: RM3 term number
            fb_docs: RM3 number of docs
            fb_lambda: RM3 lambda
            **kwargs: same arguments of `PlainPipeline`
        &#34;&#34;&#34;
        super().__init__(**kwargs)
        self._coref = AllennlpCoreferenceQueryRewriter(
            cache_dir=cache_dir, autosave=autosave, allow_cuda=allow_cuda, **kwargs)

    def run_on(self, queries: pd.DataFrame, parallel_pool: Optional[Pool] = None) -&gt; pd.DataFrame:
        return super().run_on(self._coref(queries), parallel_pool)

    @property
    def name(self):
        &#34;&#34;&#34;DLM_Coref1_[rm3]&#34;&#34;&#34;
        if self._apply_rm3:
            return f&#39;{self._steps[0].name}_{self._coref.name}_{self._steps[1].name}&#39;
        return f&#39;{self._steps[0].name}_{self._coref.name}_none&#39;


class Coreference2Pipeline(AbstractDLMConversationalPipeline):
    &#34;&#34;&#34;
    DirichletLM pipeline with Coref2 (neuralcoref) query rewriting and optional RM3
    &#34;&#34;&#34;
    def __init__(self, nlp: str = &#39;default&#39;, **kwargs):
        &#34;&#34;&#34;
        Args:
            nlp: nlp variant. Check `convSearchPython.searching.rewriter.neuralcoref_coref_query.NeuralCorefRewriter`
            for more information
            index: index to use (as RetrieveMetadata enum)
            metadata: metadata to retrieve
            rm3: if to apply RM3
            mu: mu parameter of dirichlet language model
            fb_terms: RM3 term number
            fb_docs: RM3 number of docs
            fb_lambda: RM3 lambda
            **kwargs: same arguments of `PlainPipeline`
        &#34;&#34;&#34;
        super().__init__(**kwargs)
        self._steps = [NeuralCorefRewriter(nlp=nlp, **kwargs)] + self._steps

    @property
    def name(self):
        &#34;&#34;&#34;DLM_Coref2_[rm3]&#34;&#34;&#34;
        if self._apply_rm3:
            return f&#39;{self._steps[1].name}_{self._steps[0].name}_{self._steps[2].name}&#39;
        return f&#39;{self._steps[1].name}_{self._steps[0].name}_none&#39;


class PlainBM25Pipeline(AbstractParallelPipeline):
    &#34;&#34;&#34;
    BM25 pipeline with no query rewriting and optional RM3
    &#34;&#34;&#34;
    def __init__(self, index: str, metadata: list, rm3=False, c=0.75, fb_terms=20, fb_docs=20,
                 fb_lambda=0.5, **kwargs):
        &#34;&#34;&#34;
        Args:
            index: index name
            metadata: metadata to retrieve
            rm3: if to apply RM3
            c: BM25 c parameter
            fb_terms: RM3 term number
            fb_docs: RM3 number of docs
            fb_lambda: RM3 lambda
            **kwargs: extra unused arguments
        &#34;&#34;&#34;
        super().__init__(**kwargs)
        self._c = c
        self._index = index
        self._metadata = metadata
        self._fb_terms = fb_terms
        self._fb_docs = fb_docs
        self._fb_lambda = fb_lambda
        self._apply_rm3 = rm3

        steps = [Model(&#39;BM25&#39;, {&#39;c&#39;: self._c}, self._index, self._metadata)]
        if self._apply_rm3:
            steps.append(RM3(self._index, self._fb_terms, self._fb_docs, self._fb_lambda))
            steps.append(steps[0])
        self._steps = steps

    def run_on(self, queries: pd.DataFrame, parallel_pool: Optional[Pool] = None):
        results = queries

        if parallel_pool is None:
            for step in self._steps:
                results = step(results)
            return results

        for step in self._steps:
            results = self._parallel_run(step, parallel_pool, queries)
        return results

    @property
    def name(self):
        &#34;&#34;&#34;BM25_none_[rm3]&#34;&#34;&#34;
        if self._apply_rm3:
            return f&#39;{self._steps[0].name}_none_{self._steps[1].name}&#39;
        return f&#39;{self._steps[0].name}_none_none&#39;


class ConcatQueryPipeline(AbstractDLMConversationalPipeline):
    &#34;&#34;&#34;
    Pipeline that rewrite queries with the concatenation of
    all utterance in the conversation up to that point
    &#34;&#34;&#34;
    def __init__(self, **kwargs):
        &#34;&#34;&#34;
        Args:
            conversations: conversations structure
            index: index to use (as RetrieveMetadata enum)
            metadata: metadata to retrieve
            rm3: if to apply RM3
            mu: mu parameter of dirichlet language model
            fb_terms: RM3 term number
            fb_docs: RM3 number of docs
            fb_lambda: RM3 lambda
            **kwargs: same arguments of `PlainPipeline`
        &#34;&#34;&#34;
        super().__init__(**kwargs)
        self._steps = [ConcatQueryRewriter(**kwargs)] + self._steps

    @property
    def name(self):
        &#34;&#34;&#34;DLM_ConcatQ_[rm3]&#34;&#34;&#34;
        if self._apply_rm3:
            return f&#39;{self._steps[1].name}_{self._steps[0].name}_{self._steps[2].name}&#39;
        return f&#39;{self._steps[1].name}_{self._steps[0].name}_none&#39;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="convSearchPython.pipelines.baselines.PlainPipeline"><code class="flex name class">
<span>class <span class="ident">PlainPipeline</span></span>
<span>(</span><span>index: str, metadata: list, rm3=False, mu=2500, fb_terms=20, fb_docs=20, fb_lambda=0.5, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>DirichletLM pipeline with no query rewriting and optional RM3</p>
<p>Configure with:</p>
<pre><code>plain = convSearchPython.pipelines.baselines.PlainPipeline
plain.mu = 2500
plain.rm3 = false
plain.fb_terms = 20
plain.fb_docs = 20
plain.fb_lambda = 0.5
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>index</code></strong></dt>
<dd>index to use (as RetrieveMetadata enum)</dd>
<dt><strong><code>metadata</code></strong></dt>
<dd>metadata to retrieve</dd>
<dt><strong><code>rm3</code></strong></dt>
<dd>if to apply RM3</dd>
<dt><strong><code>mu</code></strong></dt>
<dd>mu parameter of dirichlet language model</dd>
<dt><strong><code>fb_terms</code></strong></dt>
<dd>RM3 term number</dd>
<dt><strong><code>fb_docs</code></strong></dt>
<dd>RM3 number of docs</dd>
<dt><strong><code>fb_lambda</code></strong></dt>
<dd>RM3 lambda</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>extra unused arguments</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PlainPipeline(AbstractParallelPipeline):
    &#34;&#34;&#34;
    DirichletLM pipeline with no query rewriting and optional RM3

    Configure with:

    ```
    plain = convSearchPython.pipelines.baselines.PlainPipeline
    plain.mu = 2500
    plain.rm3 = false
    plain.fb_terms = 20
    plain.fb_docs = 20
    plain.fb_lambda = 0.5
    ```
    &#34;&#34;&#34;
    def __init__(self, index: str, metadata: list, rm3=False, mu=2500, fb_terms=20, fb_docs=20,
                 fb_lambda=0.5, **kwargs):
        &#34;&#34;&#34;
        Args:
            index: index to use (as RetrieveMetadata enum)
            metadata: metadata to retrieve
            rm3: if to apply RM3
            mu: mu parameter of dirichlet language model
            fb_terms: RM3 term number
            fb_docs: RM3 number of docs
            fb_lambda: RM3 lambda
            **kwargs: extra unused arguments
        &#34;&#34;&#34;
        super().__init__(**kwargs)
        self._index = index
        self._metadata = metadata
        self._fb_terms = fb_terms
        self._fb_docs = fb_docs
        self._fb_lambda = fb_lambda
        self._apply_rm3 = rm3
        self._mu = mu

        steps = [Model(&#39;DirichletLM&#39;, {&#39;c&#39;: self._mu}, self._index, self._metadata)]
        if self._apply_rm3:
            steps.append(RM3(self._index, self._fb_terms, self._fb_docs, self._fb_lambda))
            steps.append(steps[0])
        self._steps = steps

    def run_on(self, queries: pd.DataFrame, parallel_pool: Optional[Pool] = None) -&gt; pd.DataFrame:
        results = queries

        if parallel_pool is None:
            for step in self._steps:
                results = step(results)
            return results

        for step in self._steps:
            results = self._parallel_run(step, parallel_pool, queries)
        return results

    @property
    def name(self):
        &#34;&#34;&#34;DLM_none_[rm3]&#34;&#34;&#34;
        if self._apply_rm3:
            return f&#39;{self._steps[0].name}_none_{self._steps[1].name}&#39;
        return f&#39;{self._steps[0].name}_none_none&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="convSearchPython.pipelines.AbstractParallelPipeline" href="index.html#convSearchPython.pipelines.AbstractParallelPipeline">AbstractParallelPipeline</a></li>
<li><a title="convSearchPython.pipelines.Pipeline" href="index.html#convSearchPython.pipelines.Pipeline">Pipeline</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="convSearchPython.pipelines.baselines.AbstractDLMConversationalPipeline" href="#convSearchPython.pipelines.baselines.AbstractDLMConversationalPipeline">AbstractDLMConversationalPipeline</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="convSearchPython.pipelines.baselines.PlainPipeline.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>DLM_none_[rm3]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self):
    &#34;&#34;&#34;DLM_none_[rm3]&#34;&#34;&#34;
    if self._apply_rm3:
        return f&#39;{self._steps[0].name}_none_{self._steps[1].name}&#39;
    return f&#39;{self._steps[0].name}_none_none&#39;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="convSearchPython.pipelines.AbstractParallelPipeline" href="index.html#convSearchPython.pipelines.AbstractParallelPipeline">AbstractParallelPipeline</a></b></code>:
<ul class="hlist">
<li><code><a title="convSearchPython.pipelines.AbstractParallelPipeline.__call__" href="index.html#convSearchPython.pipelines.Pipeline.__call__">__call__</a></code></li>
<li><code><a title="convSearchPython.pipelines.AbstractParallelPipeline._conv_parallel_run" href="index.html#convSearchPython.pipelines.AbstractParallelPipeline._conv_parallel_run">_conv_parallel_run</a></code></li>
<li><code><a title="convSearchPython.pipelines.AbstractParallelPipeline._parallel_run" href="index.html#convSearchPython.pipelines.AbstractParallelPipeline._parallel_run">_parallel_run</a></code></li>
<li><code><a title="convSearchPython.pipelines.AbstractParallelPipeline.run_on" href="index.html#convSearchPython.pipelines.Pipeline.run_on">run_on</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="convSearchPython.pipelines.baselines.AbstractDLMConversationalPipeline"><code class="flex name class">
<span>class <span class="ident">AbstractDLMConversationalPipeline</span></span>
<span>(</span><span>conversations: Dict[str, List[str]], **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Abstract class for conversational pipeline with DLM and optional RM3</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>conversations</code></strong></dt>
<dd>conversations structure</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>same arguments of <code><a title="convSearchPython.pipelines.baselines.PlainPipeline" href="#convSearchPython.pipelines.baselines.PlainPipeline">PlainPipeline</a></code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AbstractDLMConversationalPipeline(PlainPipeline, ABC):
    &#34;&#34;&#34;
    Abstract class for conversational pipeline with DLM and optional RM3
    &#34;&#34;&#34;
    def __init__(self, conversations: Conversations, **kwargs):
        &#34;&#34;&#34;
        Args:
            conversations: conversations structure
            **kwargs: same arguments of `PlainPipeline`
        &#34;&#34;&#34;
        super().__init__(**kwargs)
        self._conversations = conversations

    def run_on(self, queries: pd.DataFrame, parallel_pool: Optional[Pool] = None) -&gt; pd.DataFrame:
        results = queries

        if parallel_pool is None:
            for step in self._steps:
                results = step(results)
            return results

        for step in self._steps:
            results = self._conv_parallel_run(step, parallel_pool, results, self._conversations)

        return results</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="convSearchPython.pipelines.baselines.PlainPipeline" href="#convSearchPython.pipelines.baselines.PlainPipeline">PlainPipeline</a></li>
<li><a title="convSearchPython.pipelines.AbstractParallelPipeline" href="index.html#convSearchPython.pipelines.AbstractParallelPipeline">AbstractParallelPipeline</a></li>
<li><a title="convSearchPython.pipelines.Pipeline" href="index.html#convSearchPython.pipelines.Pipeline">Pipeline</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="convSearchPython.pipelines.baselines.ConcatQueryPipeline" href="#convSearchPython.pipelines.baselines.ConcatQueryPipeline">ConcatQueryPipeline</a></li>
<li><a title="convSearchPython.pipelines.baselines.ContextQueryPipeline" href="#convSearchPython.pipelines.baselines.ContextQueryPipeline">ContextQueryPipeline</a></li>
<li><a title="convSearchPython.pipelines.baselines.Coreference1Pipeline" href="#convSearchPython.pipelines.baselines.Coreference1Pipeline">Coreference1Pipeline</a></li>
<li><a title="convSearchPython.pipelines.baselines.Coreference2Pipeline" href="#convSearchPython.pipelines.baselines.Coreference2Pipeline">Coreference2Pipeline</a></li>
<li><a title="convSearchPython.pipelines.baselines.FirstQueryPipeline" href="#convSearchPython.pipelines.baselines.FirstQueryPipeline">FirstQueryPipeline</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="convSearchPython.pipelines.baselines.PlainPipeline" href="#convSearchPython.pipelines.baselines.PlainPipeline">PlainPipeline</a></b></code>:
<ul class="hlist">
<li><code><a title="convSearchPython.pipelines.baselines.PlainPipeline.__call__" href="index.html#convSearchPython.pipelines.Pipeline.__call__">__call__</a></code></li>
<li><code><a title="convSearchPython.pipelines.baselines.PlainPipeline._conv_parallel_run" href="index.html#convSearchPython.pipelines.AbstractParallelPipeline._conv_parallel_run">_conv_parallel_run</a></code></li>
<li><code><a title="convSearchPython.pipelines.baselines.PlainPipeline._parallel_run" href="index.html#convSearchPython.pipelines.AbstractParallelPipeline._parallel_run">_parallel_run</a></code></li>
<li><code><a title="convSearchPython.pipelines.baselines.PlainPipeline.name" href="#convSearchPython.pipelines.baselines.PlainPipeline.name">name</a></code></li>
<li><code><a title="convSearchPython.pipelines.baselines.PlainPipeline.run_on" href="index.html#convSearchPython.pipelines.Pipeline.run_on">run_on</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="convSearchPython.pipelines.baselines.FirstQueryPipeline"><code class="flex name class">
<span>class <span class="ident">FirstQueryPipeline</span></span>
<span>(</span><span>variant='no-repeat', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>DirichletLM pipeline with first query rewriting and optional RM3</p>
<p>Configure with:</p>
<pre><code>first = convSearchPython.pipelines.baselines.FirstQueryPipeline
first.mu = 2500
first.rm3 = false
first.fb_terms = 20
first.fb_docs = 20
first.fb_lambda = 0.5
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>variant</code></strong></dt>
<dd>rewriter variant. Check <code><a title="convSearchPython.searching.rewriter.first_query.FirstQueryRewriter" href="../searching/rewriter/first_query.html#convSearchPython.searching.rewriter.first_query.FirstQueryRewriter">FirstQueryRewriter</a></code></dd>
<dt>for more information.</dt>
<dt><strong><code>conversations</code></strong></dt>
<dd>conversations structure</dd>
<dt><strong><code>index</code></strong></dt>
<dd>index to use (as RetrieveMetadata enum)</dd>
<dt><strong><code>metadata</code></strong></dt>
<dd>metadata to retrieve</dd>
<dt><strong><code>rm3</code></strong></dt>
<dd>if to apply RM3</dd>
<dt><strong><code>mu</code></strong></dt>
<dd>mu parameter of dirichlet language model</dd>
<dt><strong><code>fb_terms</code></strong></dt>
<dd>RM3 term number</dd>
<dt><strong><code>fb_docs</code></strong></dt>
<dd>RM3 number of docs</dd>
<dt><strong><code>fb_lambda</code></strong></dt>
<dd>RM3 lambda</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>same arguments of <code><a title="convSearchPython.pipelines.baselines.PlainPipeline" href="#convSearchPython.pipelines.baselines.PlainPipeline">PlainPipeline</a></code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FirstQueryPipeline(AbstractDLMConversationalPipeline):
    &#34;&#34;&#34;
    DirichletLM pipeline with first query rewriting and optional RM3

    Configure with:

    ```
    first = convSearchPython.pipelines.baselines.FirstQueryPipeline
    first.mu = 2500
    first.rm3 = false
    first.fb_terms = 20
    first.fb_docs = 20
    first.fb_lambda = 0.5
    ```
    &#34;&#34;&#34;

    def __init__(self, variant=&#39;no-repeat&#39;, **kwargs):
        &#34;&#34;&#34;
        Args:
            variant: rewriter variant. Check `convSearchPython.searching.rewriter.first_query.FirstQueryRewriter`
            for more information.
            conversations: conversations structure
            index: index to use (as RetrieveMetadata enum)
            metadata: metadata to retrieve
            rm3: if to apply RM3
            mu: mu parameter of dirichlet language model
            fb_terms: RM3 term number
            fb_docs: RM3 number of docs
            fb_lambda: RM3 lambda
            **kwargs: same arguments of `PlainPipeline`
        &#34;&#34;&#34;
        super().__init__(**kwargs)
        self._steps = [FirstQueryRewriter(variant=variant, **kwargs)] + self._steps

    def run_on(self, queries: pd.DataFrame, parallel_pool: Optional[Pool] = None) -&gt; pd.DataFrame:
        results = queries

        if parallel_pool is None:
            for step in self._steps:
                results = step(results)
            return results

        for step in self._steps:
            results = self._conv_parallel_run(step, parallel_pool, results, self._conversations)

    @property
    def name(self):
        &#34;&#34;&#34;DLM_FirstQ_[rm3]&#34;&#34;&#34;
        if self._apply_rm3:
            return f&#39;{self._steps[1].name}_{self._steps[0].name}_{self._steps[2].name}&#39;
        return f&#39;{self._steps[1].name}_{self._steps[0].name}_none&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="convSearchPython.pipelines.baselines.AbstractDLMConversationalPipeline" href="#convSearchPython.pipelines.baselines.AbstractDLMConversationalPipeline">AbstractDLMConversationalPipeline</a></li>
<li><a title="convSearchPython.pipelines.baselines.PlainPipeline" href="#convSearchPython.pipelines.baselines.PlainPipeline">PlainPipeline</a></li>
<li><a title="convSearchPython.pipelines.AbstractParallelPipeline" href="index.html#convSearchPython.pipelines.AbstractParallelPipeline">AbstractParallelPipeline</a></li>
<li><a title="convSearchPython.pipelines.Pipeline" href="index.html#convSearchPython.pipelines.Pipeline">Pipeline</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="convSearchPython.pipelines.baselines.FirstQueryPipeline.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>DLM_FirstQ_[rm3]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self):
    &#34;&#34;&#34;DLM_FirstQ_[rm3]&#34;&#34;&#34;
    if self._apply_rm3:
        return f&#39;{self._steps[1].name}_{self._steps[0].name}_{self._steps[2].name}&#39;
    return f&#39;{self._steps[1].name}_{self._steps[0].name}_none&#39;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="convSearchPython.pipelines.baselines.AbstractDLMConversationalPipeline" href="#convSearchPython.pipelines.baselines.AbstractDLMConversationalPipeline">AbstractDLMConversationalPipeline</a></b></code>:
<ul class="hlist">
<li><code><a title="convSearchPython.pipelines.baselines.AbstractDLMConversationalPipeline.__call__" href="index.html#convSearchPython.pipelines.Pipeline.__call__">__call__</a></code></li>
<li><code><a title="convSearchPython.pipelines.baselines.AbstractDLMConversationalPipeline._conv_parallel_run" href="index.html#convSearchPython.pipelines.AbstractParallelPipeline._conv_parallel_run">_conv_parallel_run</a></code></li>
<li><code><a title="convSearchPython.pipelines.baselines.AbstractDLMConversationalPipeline._parallel_run" href="index.html#convSearchPython.pipelines.AbstractParallelPipeline._parallel_run">_parallel_run</a></code></li>
<li><code><a title="convSearchPython.pipelines.baselines.AbstractDLMConversationalPipeline.run_on" href="index.html#convSearchPython.pipelines.Pipeline.run_on">run_on</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="convSearchPython.pipelines.baselines.ContextQueryPipeline"><code class="flex name class">
<span>class <span class="ident">ContextQueryPipeline</span></span>
<span>(</span><span>variant='no-repeat', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>DirichletLM pipeline with context query rewriting and optional RM3</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>variant</code></strong></dt>
<dd>rewriter variant. Check <code><a title="convSearchPython.searching.rewriter.context_query.ContextQueryRewriter" href="../searching/rewriter/context_query.html#convSearchPython.searching.rewriter.context_query.ContextQueryRewriter">ContextQueryRewriter</a></code></dd>
<dt>for more information.</dt>
<dt><strong><code>conversations</code></strong></dt>
<dd>conversations structure</dd>
<dt><strong><code>index</code></strong></dt>
<dd>index to use (as RetrieveMetadata enum)</dd>
<dt><strong><code>metadata</code></strong></dt>
<dd>metadata to retrieve</dd>
<dt><strong><code>rm3</code></strong></dt>
<dd>if to apply RM3</dd>
<dt><strong><code>mu</code></strong></dt>
<dd>mu parameter of dirichlet language model</dd>
<dt><strong><code>fb_terms</code></strong></dt>
<dd>RM3 term number</dd>
<dt><strong><code>fb_docs</code></strong></dt>
<dd>RM3 number of docs</dd>
<dt><strong><code>fb_lambda</code></strong></dt>
<dd>RM3 lambda</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>same arguments of <code><a title="convSearchPython.pipelines.baselines.PlainPipeline" href="#convSearchPython.pipelines.baselines.PlainPipeline">PlainPipeline</a></code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ContextQueryPipeline(AbstractDLMConversationalPipeline):
    &#34;&#34;&#34;
    DirichletLM pipeline with context query rewriting and optional RM3
    &#34;&#34;&#34;
    def __init__(self, variant=&#39;no-repeat&#39;, **kwargs):
        &#34;&#34;&#34;
        Args:
            variant: rewriter variant. Check `convSearchPython.searching.rewriter.context_query.ContextQueryRewriter`
            for more information.
            conversations: conversations structure
            index: index to use (as RetrieveMetadata enum)
            metadata: metadata to retrieve
            rm3: if to apply RM3
            mu: mu parameter of dirichlet language model
            fb_terms: RM3 term number
            fb_docs: RM3 number of docs
            fb_lambda: RM3 lambda
            **kwargs: same arguments of `PlainPipeline`
        &#34;&#34;&#34;
        super().__init__(**kwargs)
        self._steps = [ContextQueryRewriter(variant=variant, **kwargs)] + self._steps

    @property
    def name(self):
        &#34;&#34;&#34;DLM_ContextQ_[rm3]&#34;&#34;&#34;
        if self._apply_rm3:
            return f&#39;{self._steps[1].name}_{self._steps[0].name}_{self._steps[2].name}&#39;
        return f&#39;{self._steps[1].name}_{self._steps[0].name}_none&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="convSearchPython.pipelines.baselines.AbstractDLMConversationalPipeline" href="#convSearchPython.pipelines.baselines.AbstractDLMConversationalPipeline">AbstractDLMConversationalPipeline</a></li>
<li><a title="convSearchPython.pipelines.baselines.PlainPipeline" href="#convSearchPython.pipelines.baselines.PlainPipeline">PlainPipeline</a></li>
<li><a title="convSearchPython.pipelines.AbstractParallelPipeline" href="index.html#convSearchPython.pipelines.AbstractParallelPipeline">AbstractParallelPipeline</a></li>
<li><a title="convSearchPython.pipelines.Pipeline" href="index.html#convSearchPython.pipelines.Pipeline">Pipeline</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="convSearchPython.pipelines.baselines.ContextQueryPipeline.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>DLM_ContextQ_[rm3]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self):
    &#34;&#34;&#34;DLM_ContextQ_[rm3]&#34;&#34;&#34;
    if self._apply_rm3:
        return f&#39;{self._steps[1].name}_{self._steps[0].name}_{self._steps[2].name}&#39;
    return f&#39;{self._steps[1].name}_{self._steps[0].name}_none&#39;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="convSearchPython.pipelines.baselines.AbstractDLMConversationalPipeline" href="#convSearchPython.pipelines.baselines.AbstractDLMConversationalPipeline">AbstractDLMConversationalPipeline</a></b></code>:
<ul class="hlist">
<li><code><a title="convSearchPython.pipelines.baselines.AbstractDLMConversationalPipeline.__call__" href="index.html#convSearchPython.pipelines.Pipeline.__call__">__call__</a></code></li>
<li><code><a title="convSearchPython.pipelines.baselines.AbstractDLMConversationalPipeline._conv_parallel_run" href="index.html#convSearchPython.pipelines.AbstractParallelPipeline._conv_parallel_run">_conv_parallel_run</a></code></li>
<li><code><a title="convSearchPython.pipelines.baselines.AbstractDLMConversationalPipeline._parallel_run" href="index.html#convSearchPython.pipelines.AbstractParallelPipeline._parallel_run">_parallel_run</a></code></li>
<li><code><a title="convSearchPython.pipelines.baselines.AbstractDLMConversationalPipeline.run_on" href="index.html#convSearchPython.pipelines.Pipeline.run_on">run_on</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="convSearchPython.pipelines.baselines.Coreference1Pipeline"><code class="flex name class">
<span>class <span class="ident">Coreference1Pipeline</span></span>
<span>(</span><span>cache_dir: Union[str, pathlib.Path], allow_cuda=True, autosave=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>DirichletLM pipeline with Coref1 (alennlp) query rewriting and optional RM3</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cache_dir</code></strong></dt>
<dd>the cache dir path (None disable cache)</dd>
<dt><strong><code>allow_cuda</code></strong></dt>
<dd>if True cuda is used if available</dd>
<dt><strong><code>autosave</code></strong></dt>
<dd>if True the cache is automatically saved</dd>
<dt><strong><code>conversations</code></strong></dt>
<dd>conversations structure</dd>
<dt><strong><code>index</code></strong></dt>
<dd>index to use (as RetrieveMetadata enum)</dd>
<dt><strong><code>metadata</code></strong></dt>
<dd>metadata to retrieve</dd>
<dt><strong><code>rm3</code></strong></dt>
<dd>if to apply RM3</dd>
<dt><strong><code>mu</code></strong></dt>
<dd>mu parameter of dirichlet language model</dd>
<dt><strong><code>fb_terms</code></strong></dt>
<dd>RM3 term number</dd>
<dt><strong><code>fb_docs</code></strong></dt>
<dd>RM3 number of docs</dd>
<dt><strong><code>fb_lambda</code></strong></dt>
<dd>RM3 lambda</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>same arguments of <code><a title="convSearchPython.pipelines.baselines.PlainPipeline" href="#convSearchPython.pipelines.baselines.PlainPipeline">PlainPipeline</a></code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Coreference1Pipeline(AbstractDLMConversationalPipeline):
    &#34;&#34;&#34;
    DirichletLM pipeline with Coref1 (alennlp) query rewriting and optional RM3
    &#34;&#34;&#34;
    def __init__(self, cache_dir: Union[str, Path], allow_cuda=True, autosave=True, **kwargs):
        &#34;&#34;&#34;
        Args:
            cache_dir: the cache dir path (None disable cache)
            allow_cuda: if True cuda is used if available
            autosave: if True the cache is automatically saved
            conversations: conversations structure
            index: index to use (as RetrieveMetadata enum)
            metadata: metadata to retrieve
            rm3: if to apply RM3
            mu: mu parameter of dirichlet language model
            fb_terms: RM3 term number
            fb_docs: RM3 number of docs
            fb_lambda: RM3 lambda
            **kwargs: same arguments of `PlainPipeline`
        &#34;&#34;&#34;
        super().__init__(**kwargs)
        self._coref = AllennlpCoreferenceQueryRewriter(
            cache_dir=cache_dir, autosave=autosave, allow_cuda=allow_cuda, **kwargs)

    def run_on(self, queries: pd.DataFrame, parallel_pool: Optional[Pool] = None) -&gt; pd.DataFrame:
        return super().run_on(self._coref(queries), parallel_pool)

    @property
    def name(self):
        &#34;&#34;&#34;DLM_Coref1_[rm3]&#34;&#34;&#34;
        if self._apply_rm3:
            return f&#39;{self._steps[0].name}_{self._coref.name}_{self._steps[1].name}&#39;
        return f&#39;{self._steps[0].name}_{self._coref.name}_none&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="convSearchPython.pipelines.baselines.AbstractDLMConversationalPipeline" href="#convSearchPython.pipelines.baselines.AbstractDLMConversationalPipeline">AbstractDLMConversationalPipeline</a></li>
<li><a title="convSearchPython.pipelines.baselines.PlainPipeline" href="#convSearchPython.pipelines.baselines.PlainPipeline">PlainPipeline</a></li>
<li><a title="convSearchPython.pipelines.AbstractParallelPipeline" href="index.html#convSearchPython.pipelines.AbstractParallelPipeline">AbstractParallelPipeline</a></li>
<li><a title="convSearchPython.pipelines.Pipeline" href="index.html#convSearchPython.pipelines.Pipeline">Pipeline</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="convSearchPython.pipelines.baselines.Coreference1Pipeline.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>DLM_Coref1_[rm3]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self):
    &#34;&#34;&#34;DLM_Coref1_[rm3]&#34;&#34;&#34;
    if self._apply_rm3:
        return f&#39;{self._steps[0].name}_{self._coref.name}_{self._steps[1].name}&#39;
    return f&#39;{self._steps[0].name}_{self._coref.name}_none&#39;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="convSearchPython.pipelines.baselines.AbstractDLMConversationalPipeline" href="#convSearchPython.pipelines.baselines.AbstractDLMConversationalPipeline">AbstractDLMConversationalPipeline</a></b></code>:
<ul class="hlist">
<li><code><a title="convSearchPython.pipelines.baselines.AbstractDLMConversationalPipeline.__call__" href="index.html#convSearchPython.pipelines.Pipeline.__call__">__call__</a></code></li>
<li><code><a title="convSearchPython.pipelines.baselines.AbstractDLMConversationalPipeline._conv_parallel_run" href="index.html#convSearchPython.pipelines.AbstractParallelPipeline._conv_parallel_run">_conv_parallel_run</a></code></li>
<li><code><a title="convSearchPython.pipelines.baselines.AbstractDLMConversationalPipeline._parallel_run" href="index.html#convSearchPython.pipelines.AbstractParallelPipeline._parallel_run">_parallel_run</a></code></li>
<li><code><a title="convSearchPython.pipelines.baselines.AbstractDLMConversationalPipeline.run_on" href="index.html#convSearchPython.pipelines.Pipeline.run_on">run_on</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="convSearchPython.pipelines.baselines.Coreference2Pipeline"><code class="flex name class">
<span>class <span class="ident">Coreference2Pipeline</span></span>
<span>(</span><span>nlp: str = 'default', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>DirichletLM pipeline with Coref2 (neuralcoref) query rewriting and optional RM3</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>nlp</code></strong></dt>
<dd>nlp variant. Check <code><a title="convSearchPython.searching.rewriter.neuralcoref_coref_query.NeuralCorefRewriter" href="../searching/rewriter/neuralcoref_coref_query.html#convSearchPython.searching.rewriter.neuralcoref_coref_query.NeuralCorefRewriter">NeuralCorefRewriter</a></code></dd>
<dt>for more information</dt>
<dt><strong><code>index</code></strong></dt>
<dd>index to use (as RetrieveMetadata enum)</dd>
<dt><strong><code>metadata</code></strong></dt>
<dd>metadata to retrieve</dd>
<dt><strong><code>rm3</code></strong></dt>
<dd>if to apply RM3</dd>
<dt><strong><code>mu</code></strong></dt>
<dd>mu parameter of dirichlet language model</dd>
<dt><strong><code>fb_terms</code></strong></dt>
<dd>RM3 term number</dd>
<dt><strong><code>fb_docs</code></strong></dt>
<dd>RM3 number of docs</dd>
<dt><strong><code>fb_lambda</code></strong></dt>
<dd>RM3 lambda</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>same arguments of <code><a title="convSearchPython.pipelines.baselines.PlainPipeline" href="#convSearchPython.pipelines.baselines.PlainPipeline">PlainPipeline</a></code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Coreference2Pipeline(AbstractDLMConversationalPipeline):
    &#34;&#34;&#34;
    DirichletLM pipeline with Coref2 (neuralcoref) query rewriting and optional RM3
    &#34;&#34;&#34;
    def __init__(self, nlp: str = &#39;default&#39;, **kwargs):
        &#34;&#34;&#34;
        Args:
            nlp: nlp variant. Check `convSearchPython.searching.rewriter.neuralcoref_coref_query.NeuralCorefRewriter`
            for more information
            index: index to use (as RetrieveMetadata enum)
            metadata: metadata to retrieve
            rm3: if to apply RM3
            mu: mu parameter of dirichlet language model
            fb_terms: RM3 term number
            fb_docs: RM3 number of docs
            fb_lambda: RM3 lambda
            **kwargs: same arguments of `PlainPipeline`
        &#34;&#34;&#34;
        super().__init__(**kwargs)
        self._steps = [NeuralCorefRewriter(nlp=nlp, **kwargs)] + self._steps

    @property
    def name(self):
        &#34;&#34;&#34;DLM_Coref2_[rm3]&#34;&#34;&#34;
        if self._apply_rm3:
            return f&#39;{self._steps[1].name}_{self._steps[0].name}_{self._steps[2].name}&#39;
        return f&#39;{self._steps[1].name}_{self._steps[0].name}_none&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="convSearchPython.pipelines.baselines.AbstractDLMConversationalPipeline" href="#convSearchPython.pipelines.baselines.AbstractDLMConversationalPipeline">AbstractDLMConversationalPipeline</a></li>
<li><a title="convSearchPython.pipelines.baselines.PlainPipeline" href="#convSearchPython.pipelines.baselines.PlainPipeline">PlainPipeline</a></li>
<li><a title="convSearchPython.pipelines.AbstractParallelPipeline" href="index.html#convSearchPython.pipelines.AbstractParallelPipeline">AbstractParallelPipeline</a></li>
<li><a title="convSearchPython.pipelines.Pipeline" href="index.html#convSearchPython.pipelines.Pipeline">Pipeline</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="convSearchPython.pipelines.baselines.Coreference2Pipeline.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>DLM_Coref2_[rm3]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self):
    &#34;&#34;&#34;DLM_Coref2_[rm3]&#34;&#34;&#34;
    if self._apply_rm3:
        return f&#39;{self._steps[1].name}_{self._steps[0].name}_{self._steps[2].name}&#39;
    return f&#39;{self._steps[1].name}_{self._steps[0].name}_none&#39;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="convSearchPython.pipelines.baselines.AbstractDLMConversationalPipeline" href="#convSearchPython.pipelines.baselines.AbstractDLMConversationalPipeline">AbstractDLMConversationalPipeline</a></b></code>:
<ul class="hlist">
<li><code><a title="convSearchPython.pipelines.baselines.AbstractDLMConversationalPipeline.__call__" href="index.html#convSearchPython.pipelines.Pipeline.__call__">__call__</a></code></li>
<li><code><a title="convSearchPython.pipelines.baselines.AbstractDLMConversationalPipeline._conv_parallel_run" href="index.html#convSearchPython.pipelines.AbstractParallelPipeline._conv_parallel_run">_conv_parallel_run</a></code></li>
<li><code><a title="convSearchPython.pipelines.baselines.AbstractDLMConversationalPipeline._parallel_run" href="index.html#convSearchPython.pipelines.AbstractParallelPipeline._parallel_run">_parallel_run</a></code></li>
<li><code><a title="convSearchPython.pipelines.baselines.AbstractDLMConversationalPipeline.run_on" href="index.html#convSearchPython.pipelines.Pipeline.run_on">run_on</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="convSearchPython.pipelines.baselines.PlainBM25Pipeline"><code class="flex name class">
<span>class <span class="ident">PlainBM25Pipeline</span></span>
<span>(</span><span>index: str, metadata: list, rm3=False, c=0.75, fb_terms=20, fb_docs=20, fb_lambda=0.5, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>BM25 pipeline with no query rewriting and optional RM3</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>index</code></strong></dt>
<dd>index name</dd>
<dt><strong><code>metadata</code></strong></dt>
<dd>metadata to retrieve</dd>
<dt><strong><code>rm3</code></strong></dt>
<dd>if to apply RM3</dd>
<dt><strong><code>c</code></strong></dt>
<dd>BM25 c parameter</dd>
<dt><strong><code>fb_terms</code></strong></dt>
<dd>RM3 term number</dd>
<dt><strong><code>fb_docs</code></strong></dt>
<dd>RM3 number of docs</dd>
<dt><strong><code>fb_lambda</code></strong></dt>
<dd>RM3 lambda</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>extra unused arguments</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PlainBM25Pipeline(AbstractParallelPipeline):
    &#34;&#34;&#34;
    BM25 pipeline with no query rewriting and optional RM3
    &#34;&#34;&#34;
    def __init__(self, index: str, metadata: list, rm3=False, c=0.75, fb_terms=20, fb_docs=20,
                 fb_lambda=0.5, **kwargs):
        &#34;&#34;&#34;
        Args:
            index: index name
            metadata: metadata to retrieve
            rm3: if to apply RM3
            c: BM25 c parameter
            fb_terms: RM3 term number
            fb_docs: RM3 number of docs
            fb_lambda: RM3 lambda
            **kwargs: extra unused arguments
        &#34;&#34;&#34;
        super().__init__(**kwargs)
        self._c = c
        self._index = index
        self._metadata = metadata
        self._fb_terms = fb_terms
        self._fb_docs = fb_docs
        self._fb_lambda = fb_lambda
        self._apply_rm3 = rm3

        steps = [Model(&#39;BM25&#39;, {&#39;c&#39;: self._c}, self._index, self._metadata)]
        if self._apply_rm3:
            steps.append(RM3(self._index, self._fb_terms, self._fb_docs, self._fb_lambda))
            steps.append(steps[0])
        self._steps = steps

    def run_on(self, queries: pd.DataFrame, parallel_pool: Optional[Pool] = None):
        results = queries

        if parallel_pool is None:
            for step in self._steps:
                results = step(results)
            return results

        for step in self._steps:
            results = self._parallel_run(step, parallel_pool, queries)
        return results

    @property
    def name(self):
        &#34;&#34;&#34;BM25_none_[rm3]&#34;&#34;&#34;
        if self._apply_rm3:
            return f&#39;{self._steps[0].name}_none_{self._steps[1].name}&#39;
        return f&#39;{self._steps[0].name}_none_none&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="convSearchPython.pipelines.AbstractParallelPipeline" href="index.html#convSearchPython.pipelines.AbstractParallelPipeline">AbstractParallelPipeline</a></li>
<li><a title="convSearchPython.pipelines.Pipeline" href="index.html#convSearchPython.pipelines.Pipeline">Pipeline</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="convSearchPython.pipelines.dbpedia.DBPediaPipeline" href="dbpedia.html#convSearchPython.pipelines.dbpedia.DBPediaPipeline">DBPediaPipeline</a></li>
<li><a title="convSearchPython.pipelines.historical.BM25TokenPipeline" href="historical.html#convSearchPython.pipelines.historical.BM25TokenPipeline">BM25TokenPipeline</a></li>
<li><a title="convSearchPython.pipelines.historical.HistoricalQueryExpansionPipeline" href="historical.html#convSearchPython.pipelines.historical.HistoricalQueryExpansionPipeline">HistoricalQueryExpansionPipeline</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="convSearchPython.pipelines.baselines.PlainBM25Pipeline.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>BM25_none_[rm3]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self):
    &#34;&#34;&#34;BM25_none_[rm3]&#34;&#34;&#34;
    if self._apply_rm3:
        return f&#39;{self._steps[0].name}_none_{self._steps[1].name}&#39;
    return f&#39;{self._steps[0].name}_none_none&#39;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="convSearchPython.pipelines.AbstractParallelPipeline" href="index.html#convSearchPython.pipelines.AbstractParallelPipeline">AbstractParallelPipeline</a></b></code>:
<ul class="hlist">
<li><code><a title="convSearchPython.pipelines.AbstractParallelPipeline.__call__" href="index.html#convSearchPython.pipelines.Pipeline.__call__">__call__</a></code></li>
<li><code><a title="convSearchPython.pipelines.AbstractParallelPipeline._conv_parallel_run" href="index.html#convSearchPython.pipelines.AbstractParallelPipeline._conv_parallel_run">_conv_parallel_run</a></code></li>
<li><code><a title="convSearchPython.pipelines.AbstractParallelPipeline._parallel_run" href="index.html#convSearchPython.pipelines.AbstractParallelPipeline._parallel_run">_parallel_run</a></code></li>
<li><code><a title="convSearchPython.pipelines.AbstractParallelPipeline.run_on" href="index.html#convSearchPython.pipelines.Pipeline.run_on">run_on</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="convSearchPython.pipelines.baselines.ConcatQueryPipeline"><code class="flex name class">
<span>class <span class="ident">ConcatQueryPipeline</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Pipeline that rewrite queries with the concatenation of
all utterance in the conversation up to that point</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>conversations</code></strong></dt>
<dd>conversations structure</dd>
<dt><strong><code>index</code></strong></dt>
<dd>index to use (as RetrieveMetadata enum)</dd>
<dt><strong><code>metadata</code></strong></dt>
<dd>metadata to retrieve</dd>
<dt><strong><code>rm3</code></strong></dt>
<dd>if to apply RM3</dd>
<dt><strong><code>mu</code></strong></dt>
<dd>mu parameter of dirichlet language model</dd>
<dt><strong><code>fb_terms</code></strong></dt>
<dd>RM3 term number</dd>
<dt><strong><code>fb_docs</code></strong></dt>
<dd>RM3 number of docs</dd>
<dt><strong><code>fb_lambda</code></strong></dt>
<dd>RM3 lambda</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>same arguments of <code><a title="convSearchPython.pipelines.baselines.PlainPipeline" href="#convSearchPython.pipelines.baselines.PlainPipeline">PlainPipeline</a></code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConcatQueryPipeline(AbstractDLMConversationalPipeline):
    &#34;&#34;&#34;
    Pipeline that rewrite queries with the concatenation of
    all utterance in the conversation up to that point
    &#34;&#34;&#34;
    def __init__(self, **kwargs):
        &#34;&#34;&#34;
        Args:
            conversations: conversations structure
            index: index to use (as RetrieveMetadata enum)
            metadata: metadata to retrieve
            rm3: if to apply RM3
            mu: mu parameter of dirichlet language model
            fb_terms: RM3 term number
            fb_docs: RM3 number of docs
            fb_lambda: RM3 lambda
            **kwargs: same arguments of `PlainPipeline`
        &#34;&#34;&#34;
        super().__init__(**kwargs)
        self._steps = [ConcatQueryRewriter(**kwargs)] + self._steps

    @property
    def name(self):
        &#34;&#34;&#34;DLM_ConcatQ_[rm3]&#34;&#34;&#34;
        if self._apply_rm3:
            return f&#39;{self._steps[1].name}_{self._steps[0].name}_{self._steps[2].name}&#39;
        return f&#39;{self._steps[1].name}_{self._steps[0].name}_none&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="convSearchPython.pipelines.baselines.AbstractDLMConversationalPipeline" href="#convSearchPython.pipelines.baselines.AbstractDLMConversationalPipeline">AbstractDLMConversationalPipeline</a></li>
<li><a title="convSearchPython.pipelines.baselines.PlainPipeline" href="#convSearchPython.pipelines.baselines.PlainPipeline">PlainPipeline</a></li>
<li><a title="convSearchPython.pipelines.AbstractParallelPipeline" href="index.html#convSearchPython.pipelines.AbstractParallelPipeline">AbstractParallelPipeline</a></li>
<li><a title="convSearchPython.pipelines.Pipeline" href="index.html#convSearchPython.pipelines.Pipeline">Pipeline</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="convSearchPython.pipelines.baselines.ConcatQueryPipeline.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>DLM_ConcatQ_[rm3]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self):
    &#34;&#34;&#34;DLM_ConcatQ_[rm3]&#34;&#34;&#34;
    if self._apply_rm3:
        return f&#39;{self._steps[1].name}_{self._steps[0].name}_{self._steps[2].name}&#39;
    return f&#39;{self._steps[1].name}_{self._steps[0].name}_none&#39;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="convSearchPython.pipelines.baselines.AbstractDLMConversationalPipeline" href="#convSearchPython.pipelines.baselines.AbstractDLMConversationalPipeline">AbstractDLMConversationalPipeline</a></b></code>:
<ul class="hlist">
<li><code><a title="convSearchPython.pipelines.baselines.AbstractDLMConversationalPipeline.__call__" href="index.html#convSearchPython.pipelines.Pipeline.__call__">__call__</a></code></li>
<li><code><a title="convSearchPython.pipelines.baselines.AbstractDLMConversationalPipeline._conv_parallel_run" href="index.html#convSearchPython.pipelines.AbstractParallelPipeline._conv_parallel_run">_conv_parallel_run</a></code></li>
<li><code><a title="convSearchPython.pipelines.baselines.AbstractDLMConversationalPipeline._parallel_run" href="index.html#convSearchPython.pipelines.AbstractParallelPipeline._parallel_run">_parallel_run</a></code></li>
<li><code><a title="convSearchPython.pipelines.baselines.AbstractDLMConversationalPipeline.run_on" href="index.html#convSearchPython.pipelines.Pipeline.run_on">run_on</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="convSearchPython.pipelines" href="index.html">convSearchPython.pipelines</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="convSearchPython.pipelines.baselines.PlainPipeline" href="#convSearchPython.pipelines.baselines.PlainPipeline">PlainPipeline</a></code></h4>
<ul class="">
<li><code><a title="convSearchPython.pipelines.baselines.PlainPipeline.name" href="#convSearchPython.pipelines.baselines.PlainPipeline.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="convSearchPython.pipelines.baselines.AbstractDLMConversationalPipeline" href="#convSearchPython.pipelines.baselines.AbstractDLMConversationalPipeline">AbstractDLMConversationalPipeline</a></code></h4>
</li>
<li>
<h4><code><a title="convSearchPython.pipelines.baselines.FirstQueryPipeline" href="#convSearchPython.pipelines.baselines.FirstQueryPipeline">FirstQueryPipeline</a></code></h4>
<ul class="">
<li><code><a title="convSearchPython.pipelines.baselines.FirstQueryPipeline.name" href="#convSearchPython.pipelines.baselines.FirstQueryPipeline.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="convSearchPython.pipelines.baselines.ContextQueryPipeline" href="#convSearchPython.pipelines.baselines.ContextQueryPipeline">ContextQueryPipeline</a></code></h4>
<ul class="">
<li><code><a title="convSearchPython.pipelines.baselines.ContextQueryPipeline.name" href="#convSearchPython.pipelines.baselines.ContextQueryPipeline.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="convSearchPython.pipelines.baselines.Coreference1Pipeline" href="#convSearchPython.pipelines.baselines.Coreference1Pipeline">Coreference1Pipeline</a></code></h4>
<ul class="">
<li><code><a title="convSearchPython.pipelines.baselines.Coreference1Pipeline.name" href="#convSearchPython.pipelines.baselines.Coreference1Pipeline.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="convSearchPython.pipelines.baselines.Coreference2Pipeline" href="#convSearchPython.pipelines.baselines.Coreference2Pipeline">Coreference2Pipeline</a></code></h4>
<ul class="">
<li><code><a title="convSearchPython.pipelines.baselines.Coreference2Pipeline.name" href="#convSearchPython.pipelines.baselines.Coreference2Pipeline.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="convSearchPython.pipelines.baselines.PlainBM25Pipeline" href="#convSearchPython.pipelines.baselines.PlainBM25Pipeline">PlainBM25Pipeline</a></code></h4>
<ul class="">
<li><code><a title="convSearchPython.pipelines.baselines.PlainBM25Pipeline.name" href="#convSearchPython.pipelines.baselines.PlainBM25Pipeline.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="convSearchPython.pipelines.baselines.ConcatQueryPipeline" href="#convSearchPython.pipelines.baselines.ConcatQueryPipeline">ConcatQueryPipeline</a></code></h4>
<ul class="">
<li><code><a title="convSearchPython.pipelines.baselines.ConcatQueryPipeline.name" href="#convSearchPython.pipelines.baselines.ConcatQueryPipeline.name">name</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>